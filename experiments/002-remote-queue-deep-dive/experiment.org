#+TITLE: Experiment 002: Deep Dive into efrit-remote-queue Implementation
#+AUTHOR: Efrit Development Team  
#+STARTUP: content
#+PROPERTY: header-args :tangle yes :comments both :mkdirp yes

* Overview

This experiment analyzes the =efrit-remote-queue.el= system that provides a file-based communication mechanism between AI systems and Emacs.

* Key Finding: It's NOT a FIFO Queue!

Despite the name "queue", this is actually an *event-driven, file-based message passing system* that uses filesystem notifications rather than traditional queue data structures.

* Architecture Analysis

** Directory Structure

#+begin_example
~/.emacs.d/efrit-queue/
‚îú‚îÄ‚îÄ requests/     # AI systems write .json files here
‚îú‚îÄ‚îÄ responses/    # Efrit writes response .json files here  
‚îú‚îÄ‚îÄ processing/   # Temporary holding during processing
‚îî‚îÄ‚îÄ archive/      # Completed requests/responses
#+end_example

** How It Works

The system follows this flow:
1. AI System writes JSON to =requests/=
2. Filesystem notification triggers Efrit handler
3. Request moved to =processing/=
4. Emacs executes the request
5. Response generated in =responses/=
6. AI system reads response

* Implementation Analysis

** Queue System Test Script

#+begin_src bash :tangle test-queue.sh :shebang #!/usr/bin/env bash
# Interactive test script for efrit-remote-queue

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

QUEUE_DIR="${HOME}/.emacs.d/efrit-queue"
REQUESTS_DIR="${QUEUE_DIR}/requests"
RESPONSES_DIR="${QUEUE_DIR}/responses"

echo -e "${BLUE}üîç Efrit Remote Queue Deep Dive${NC}"
echo "=================================="
echo ""

# Check if queue directory exists
if [[ ! -d "$QUEUE_DIR" ]]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Queue directory not found: $QUEUE_DIR${NC}"
    echo "To create it, start Efrit queue system in Emacs:"
    echo "  M-x efrit-remote-queue-start"
    echo ""
    echo "Creating test directories..."
    mkdir -p "$REQUESTS_DIR" "$RESPONSES_DIR"
fi

echo -e "${GREEN}üìÅ Queue Directory Structure:${NC}"
ls -la "$QUEUE_DIR" 2>/dev/null || echo "Directory not found"
echo ""

# Function to create test request
create_test_request() {
    local request_id="$1"
    local action="$2"
    local content="$3"
    
    local request_file="${REQUESTS_DIR}/req_${request_id}.json"
    
    cat > "$request_file" << EOF
{
  "id": "req_${request_id}",
  "timestamp": "$(date -Iseconds)",
  "action": "${action}",
  "content": "${content}",
  "metadata": {
    "experiment": "002-queue-deep-dive",
    "test_mode": true
  }
}
EOF
    
    echo -e "${GREEN}‚úÖ Created request: req_${request_id}.json${NC}"
    echo "   Action: $action"
    echo "   Content: $content"
    echo ""
}

# Function to wait for response
wait_for_response() {
    local request_id="$1"
    local timeout="${2:-30}"
    local response_file="${RESPONSES_DIR}/resp_${request_id}.json"
    
    echo -e "${YELLOW}‚è≥ Waiting for response (timeout: ${timeout}s)...${NC}"
    
    for i in $(seq 1 $timeout); do
        if [[ -f "$response_file" ]]; then
            echo -e "${GREEN}üì• Response received!${NC}"
            echo "Response content:"
            cat "$response_file" | jq . 2>/dev/null || cat "$response_file"
            echo ""
            return 0
        fi
        sleep 1
        echo -n "."
    done
    
    echo ""
    echo -e "${RED}‚ùå Timeout: No response received${NC}"
    return 1
}

# Test 1: Simple evaluation
echo -e "${BLUE}üß™ Test 1: Simple Elisp Evaluation${NC}"
echo "-----------------------------------"
create_test_request "001" "eval" "(+ 40 2)"
wait_for_response "001" 10

# Test 2: Buffer operation
echo -e "${BLUE}üß™ Test 2: Buffer Operation${NC}"
echo "-----------------------------"
create_test_request "002" "eval" "(buffer-name)"
wait_for_response "002" 10

# Test 3: File operation
echo -e "${BLUE}üß™ Test 3: File System Operation${NC}"
echo "--------------------------------"
create_test_request "003" "eval" "(directory-files default-directory)"
wait_for_response "003" 10

# Test 4: Natural language (if supported)
echo -e "${BLUE}üß™ Test 4: Natural Language Request${NC}"
echo "-----------------------------------"
create_test_request "004" "natural" "What is the current time?"
wait_for_response "004" 15

# Analysis of queue behavior
echo -e "${BLUE}üìä Queue Analysis${NC}"
echo "=================="
echo ""

echo "Request files created:"
ls -la "$REQUESTS_DIR" 2>/dev/null || echo "No requests directory"
echo ""

echo "Response files received:"
ls -la "$RESPONSES_DIR" 2>/dev/null || echo "No responses directory"
echo ""

echo -e "${YELLOW}üí° Key Observations:${NC}"
echo "1. This is NOT a traditional FIFO queue"
echo "2. Uses filesystem notifications for event-driven processing"
echo "3. Each request gets its own JSON file"
echo "4. Responses are correlated by ID"
echo "5. No queuing order guarantees - it's event-based"
echo ""

echo -e "${GREEN}‚úÖ Deep dive complete!${NC}"
echo ""
echo "To start the queue system in Emacs:"
echo "  M-x efrit-remote-queue-start"
echo ""
echo "To check queue status:"
echo "  M-x efrit-remote-queue-status"
#+end_src

** Queue Behavior Analysis

#+begin_src elisp :tangle analyze-queue.el
;;; analyze-queue.el --- Analysis tools for efrit-remote-queue

;; Copyright (C) 2025 Efrit Development Team

;;; Commentary:
;; Tools to analyze and understand the efrit-remote-queue system behavior.

;;; Code:

(require 'json)

(defvar efrit-queue-base-dir
  (expand-file-name "efrit-queue" user-emacs-directory)
  "Base directory for efrit queue system.")

(defun efrit-analyze-queue-structure ()
  "Analyze the queue directory structure."
  (interactive)
  (let ((base-dir efrit-queue-base-dir))
    (message "üîç Analyzing Queue Structure")
    (message "===========================")
    (message "")
    (message "Base directory: %s" base-dir)
    
    (if (file-directory-p base-dir)
        (progn
          (message "üìÅ Directory contents:")
          (dolist (subdir '("requests" "responses" "processing" "archive"))
            (let ((path (expand-file-name subdir base-dir)))
              (if (file-directory-p path)
                  (let ((files (directory-files path nil "\.json$")))
                    (message "  %s/: %d files" subdir (length files))
                    (when files
                      (message "    Latest: %s" (car (last files)))))
                (message "  %s/: NOT FOUND" subdir)))))
      (message "‚ùå Queue directory not found"))))

(defun efrit-analyze-request-patterns ()
  "Analyze patterns in request files."
  (interactive)
  (let* ((requests-dir (expand-file-name "requests" efrit-queue-base-dir))
         (files (when (file-directory-p requests-dir)
                  (directory-files requests-dir t "\.json$"))))
    
    (message "üìä Request Pattern Analysis")
    (message "===========================")
    
    (if files
        (let ((action-counts (make-hash-table :test 'equal))
              (total-requests (length files)))
          
          ;; Analyze each request file
          (dolist (file files)
            (when (file-readable-p file)
              (condition-case err
                  (let* ((json-data (json-read-file file))
                         (action (cdr (assoc 'action json-data))))
                    (when action
                      (let ((current-count (gethash action action-counts 0)))
                        (puthash action (1+ current-count) action-counts))))
                (error
                 (message "‚ö†Ô∏è  Could not parse: %s" (file-name-nondirectory file))))))
          
          (message "Total requests: %d" total-requests)
          (message "")
          (message "Action types:")
          (maphash (lambda (action count)
                     (message "  %s: %d (%.1f%%)" 
                             action count 
                             (* 100.0 (/ (float count) total-requests))))
                   action-counts))
      (message "No request files found"))))

(defun efrit-create-test-request (id action content)
  "Create a test request with ID, ACTION, and CONTENT."
  (interactive "sRequest ID: \nsAction: \nsContent: ")
  (let* ((requests-dir (expand-file-name "requests" efrit-queue-base-dir))
         (request-file (expand-file-name (format "req_%s.json" id) requests-dir))
         (request-data `((id . ,(format "req_%s" id))
                        (timestamp . ,(format-time-string "%Y-%m-%dT%H:%M:%S%z"))
                        (action . ,action)
                        (content . ,content)
                        (metadata . ((experiment . "002-queue-deep-dive")
                                   (created-by . "analyze-queue.el"))))))
    
    ;; Ensure directory exists
    (unless (file-directory-p requests-dir)
      (make-directory requests-dir t))
    
    ;; Write request file
    (with-temp-file request-file
      (insert (json-encode request-data)))
    
    (message "‚úÖ Created test request: %s" request-file)
    (message "   ID: %s" id)
    (message "   Action: %s" action)
    (message "   Content: %s" content)))

(defun efrit-monitor-queue-activity ()
  "Monitor queue activity in real-time."
  (interactive)
  (let ((monitoring-buffer "*Efrit Queue Monitor*"))
    (with-current-buffer (get-buffer-create monitoring-buffer)
      (erase-buffer)
      (insert "üîç Efrit Queue Activity Monitor\n")
      (insert "===============================\n\n")
      (insert "Monitoring queue directory: " efrit-queue-base-dir "\n")
      (insert "Press C-c C-c to stop monitoring\n\n")
      
      ;; Set up file notification if available
      (when (fboundp 'file-notify-add-watch)
        (let ((requests-dir (expand-file-name "requests" efrit-queue-base-dir))
              (responses-dir (expand-file-name "responses" efrit-queue-base-dir)))
          
          (when (file-directory-p requests-dir)
            (file-notify-add-watch 
             requests-dir 
             '(change)
             (lambda (event)
               (with-current-buffer monitoring-buffer
                 (goto-char (point-max))
                 (insert (format "[%s] REQUEST: %s\n" 
                               (format-time-string "%H:%M:%S")
                               (file-name-nondirectory (nth 2 event))))))))
          
          (when (file-directory-p responses-dir)
            (file-notify-add-watch 
             responses-dir 
             '(change)
             (lambda (event)
               (with-current-buffer monitoring-buffer
                 (goto-char (point-max))
                 (insert (format "[%s] RESPONSE: %s\n" 
                               (format-time-string "%H:%M:%S")
                               (file-name-nondirectory (nth 2 event)))))))))
        
        (insert "‚úÖ File notifications enabled\n"))
      
      (display-buffer monitoring-buffer))))

(provide 'analyze-queue)
;;; analyze-queue.el ends here
#+end_src

* Key Insights

** Not a Traditional Queue

The system is misnamed - it's not a FIFO queue but rather:
- *Event-driven messaging system*
- *File-based communication protocol*  
- *Asynchronous request/response pattern*

** Advantages

- *Persistence*: Requests survive Emacs restarts
- *Debugging*: All messages are visible as files
- *Language Agnostic*: Any system can write JSON files
- *Atomic Operations*: File creation is atomic

** Limitations  

- *No Ordering Guarantees*: Not truly a queue
- *Filesystem Dependency*: Requires filesystem notifications
- *Scalability*: Many files in directory can be slow
- *Race Conditions*: Possible with rapid file creation

* Testing Instructions

** Prerequisites

1. Emacs with =efrit-remote-queue= loaded
2. Queue system started: =M-x efrit-remote-queue-start=

** Running Tests

#+begin_example
# Tangle files
make tangle

# Run analysis
./test-queue.sh

# Or in Emacs
(load-file "analyze-queue.el")
(efrit-analyze-queue-structure)
(efrit-monitor-queue-activity)
#+end_example

* Future Research

- [ ] Benchmark performance with large numbers of files
- [ ] Test concurrent request handling
- [ ] Analyze filesystem notification reliability
- [ ] Compare with true queue implementations
- [ ] Investigate memory usage patterns

* Conclusion

The "queue" system is actually a sophisticated file-based messaging protocol that provides reliable, persistent communication between AI systems and Emacs, despite not being a traditional queue data structure.